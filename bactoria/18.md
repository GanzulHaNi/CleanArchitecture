
# 5부. 아키텍처

## 17장. 경계 해부학

목표: 경계 형태 중 흔한 케이스 살펴보기

### 경계 횡단하기

**런타임에 경계를 횡단한다** 
런타임 경계횡단: 한쪽 경계에 있는 기능이 반대편 기능을 호출하여 데이터를 전달  

소스 코드가 변경되면 의존하는 다른 소스 코드들도 변경/컴파일 이 필요할 수 있다.

이에 소스 코드 의존성 관리를 하여 적절한 위치에서 경계를 횡단하도록 해야 한다.

경계는 이러한 변경이 전파되는 것을 막고 관리하는 수단으로 존재한다.  

### 1. 두려운 단일체 (소스 수준 분리 모드)

모놀리틱은 배포 관점에서 경계가 들어나지 않는다. (하나의 커다란 파일이므로..)

이에 모놀리틱은 다형성에 의존하여 내부 의존성을 관리한다.  

**저수준이 고수준에 의존한다**
=> 클라이언트와 서비스의 고수준/저수준 에 따라 의존성 방향이 달라진다

**저수준 클라이언트와 고수준 서비스**
<img width="400" src="https://user-images.githubusercontent.com/25674959/117564269-40bc9700-b0e6-11eb-8a1e-7175fa7b01c7.png">

**고수준 클라이언트와 저수준 서비스**
<img width="400" src="https://user-images.githubusercontent.com/25674959/117564281-58941b00-b0e6-11eb-900d-59fa1e908217.png">

모노리틱 구조인 경우 위처럼 규칙적인 방식으로 구조를 분리하면 개발, 테스트, 배포 시 큰 도움이 된다.    
고수준 컴포넌트는 저수준 세부사항으로부터 독립적으로 유지된다.   

`Data` 를 어느 컴포넌트에 위치시켜야 좋은가에 대한 해답을 찾지 못했었는데, 고수준/저수준에 따라 컴포넌트가 달라지는거구나..

&nbsp;

### 2. 배포형 컴포넌트 (배포 수준 결합 분리 모드)

아키텍처의 경계가 물리적으로 드러난다. (eg. 메이븐에 배포하는 라이브러리와 이를 사용하는 서버는 레파지토리 분리)

단일체와 마찬가지로 경계를 가로지르는 통신은 함수호출이므로 매우 값싸다. 

&nbsp;

### 3. 로컬 프로세스

강한 물리적 형태를 띠는 아키텍처 경계

고수준 프로세스가 저수준 프로세스의 정보를 포함해서는 안된다. (eg. PID, 물리주소, 레지스트리 조회 키)

메모리 공유가 되지 않으므로 통신은 운영체제 호출, 데이터 마샬링, 프로세스간 문맥교환 등 비싼 작업이다.  
따라서 통신이 너무 빈번하게 이뤄지지 않도록 신중하게 제한해야 한다.  

&nbsp;

### 4. 서비스

가장 강력한 물리적인 형태를 띠는 아키텍처 경계

서비스 경계를 지나는 통신은 함수 호출에 비해 매우 느리다. 따라서 빈번하게 통신하는 일을 피해야 한다.

**지연(latency)에 따른 문제를 고수준에서 처리할 수 있어야 한다.**  

고수준 프로세스가 저수준 프로세스의 정보를 포함해서는 안된다. (eg. URL)

&nbsp;

### 결론

단일체를 제외한 대다수의 시스템은 한 가지 이상의 경계 전략을 사용한다.  

서비스 경계를 활용하는 시스템인 경우 ?  
=> 로컬 프로세스 경계도 포함하고 있을 수 있다. 실제로 서비스는 상호작용하는 일련의 로컬 프로세스 퍼사드에 불과할 때가 많다. 또한 개별 서비스/로컬 프로세스는 링크된 배포형 컴포넌트의 집합이다.  
즉, 대체로 한 시스템 안에서도 **통신이 빈번한 로컬 경계**와 **지연을 중요하게 고려해야 하는 경계**가 혼합되어 있음을 의미한다.  


